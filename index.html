<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>overtourissimus</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- HTML2Canvas library for screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body {
            font-family: "Inter", sans-serif;
            overflow: hidden; /* Prevents scrolling of the entire page */
            margin: 0; /* Ensures no default margin */
        }
        canvas {
            touch-action: none; /* Prevents default touch actions like scroll/zoom on the canvas element itself */
            display: block; /* To remove possible bottom spacing */
        }
        .font-outfit {
            font-family: 'Outfit', sans-serif;
        }
        /* Additional style rule for the statistics displays to enforce vertical alignment */
        #allTimeStatsDisplay, #worldwideStatsDisplay {
            height: 20px; /* Set fixed height */
            line-height: 20px; /* Set line-height equal to height for vertical centering */
        }
    </style>
</head>
<body class="bg-black text-white flex flex-col items-center justify-center h-screen w-screen">
    <!-- Main container now fills the entire screen without max-width/height constraints -->
    <div class="relative w-full h-full bg-black shadow-lg overflow-hidden">
        <!-- "overtourissimus" text - Vertically aligned with the icon -->
        <div class="absolute top-0 left-0 right-0 px-4 h-[52px] z-5 flex items-center justify-center"> 
            <h1 class="text-center font-bold text-xl font-outfit tracking-widest leading-none">overtourissimus</h1>
        </div>

        <!-- New container for the screenshot button - with a high z-index to always be in the foreground -->
        <div id="screenshotButtonContainer" class="absolute top-0 right-0 py-2 px-4 z-40 flex items-center justify-end">
            <button id="screenshotButton" class="bg-gray-800 hover:bg-gray-900 text-white p-1.5 rounded-md shadow-md transition-colors duration-200 flex items-center justify-center">
                <!-- Minimalist camera SVG icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-camera">
                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3Z"/>
                    <circle cx="12" cy="13" r="3"/>
                </svg>
            </button>
        </div>

        <!-- Canvas now also absolutely positioned and with z-index:10 to be above the text -->
        <canvas id="overtourismCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>

        <!-- Message Box - remains on the highest level -->
        <div id="messageBox" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white p-6 rounded-lg shadow-xl hidden z-50 text-center">
            <p id="messageText" class="mb-4"></p>
            <button onclick="document.getElementById('messageBox').classList.add('hidden')" class="mt-2 px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium">OK</button>
        </div>
    </div>

    <!-- Container for "Remove Touris" Button -->
    <div id="clearButtonWrapper" class="absolute bottom-[72px] left-1/2 -translate-x-1/2 z-30">
        <button id="clearButton" class="font-outfit px-4 py-2 bg-blue-800 hover:bg-blue-900 text-white text-sm rounded-md shadow-md w-96 text-center">
            remove 0 touris
        </button>
    </div>

    <!-- Container for "Touris Generated" Display -->
    <div id="allTimeStatsDisplay" class="absolute bottom-[44px] left-1/2 -translate-x-1/2 font-outfit px-4 py-1 bg-black text-gray-400 text-xs rounded-md w-96 text-center border border-gray-700 flex items-center justify-center z-30">
        0 touris generated
    </div>
    
    <!-- Container for "Worldwide Removed Touris" Display -->
    <div id="worldwideStatsDisplay" class="absolute bottom-4 left-1/2 -translate-x-1/2 font-outfit px-4 py-1 bg-black text-gray-400 text-xs rounded-md w-96 text-center border border-gray-700 flex items-center justify-center z-30">
        loading global stats...
    </div>


    <script>
        const canvas = document.getElementById('overtourismCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const clearButton = document.getElementById('clearButton');
        const allTimeStatsDisplay = document.getElementById('allTimeStatsDisplay');
        const worldwideStatsDisplay = document.getElementById('worldwideStatsDisplay');
        const screenshotButton = document.getElementById('screenshotButton'); 
        const screenshotButtonContainer = document.getElementById('screenshotButtonContainer'); 
        const clearButtonWrapper = document.getElementById('clearButtonWrapper'); 

        // --- JSONBin.io Configuration ---
        // Stores the global counter.
        // Setup:
        // 1. Create an account on JSONBin.io.
        // 2. Create a new, private Bin with the content { "touristCount": 0 }.
        // 3. Enter the resulting BIN_ID here.
        // 4. Create an API key ("X-Master-Key") and enter it here.
        const BIN_ID = '688bae8df7e7a370d1f12377';
        const API_KEY = '$2a$10$4ml04tUU/v8AeAWTlckjiuKZKaa8PBiqZthe10FEwkHRfzG7Fu3Sy'; // <-- UPDATED API KEY
        const BIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
        // --- End of JSONBin.io Configuration ---

        let isDrawing = false;
        let touristCount = 0; 
        let allTimeTouristCount = 0; 
        let lastKnownX = 0;
        let lastKnownY = 0;
        let gameLoopTimeoutId = null; 
        
        const GAME_LOOP_INTERVAL = 18; // Interval for continuous drawing
        const HOLD_TO_START_LOOP_DELAY = 150; // Delay in ms before holding is considered continuous drawing

        /**
         * Fetches the current global counter value from JSONBin.
         * @returns {Promise<number>} The number of tourists.
         */
        async function getCounterValue() {
            try {
                const response = await fetch(`${BIN_URL}/latest`, { // Use /latest to get the newest version without caching issues
                    headers: { 'X-Master-Key': API_KEY }
                });
                if (!response.ok) throw new Error(`API GET Error: ${response.statusText}`);
                const data = await response.json();
                return data.record.touristCount || 0;
            } catch (err) {
                console.error("Error fetching counter value:", err);
                showMessage("Could not load global statistics.");
                return 0; // Fallback
            }
        }

        /**
         * Updates the global counter on JSONBin.
         * @param {number} newTotalCount - The new, absolute total value.
         * @returns {Promise<boolean>} True on success, false on error.
         */
        async function updateCounterValue(newTotalCount) {
            try {
                const response = await fetch(BIN_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify({ touristCount: newTotalCount })
                });
                if (!response.ok) throw new Error(`API PUT Error: ${response.statusText}`);
                return true;
            } catch (err) {
                console.error("Error updating counter value:", err);
                showMessage("Save failed. Please try again.");
                return false;
            }
        }

        /**
         * Displays a message in the custom message box.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            if (messageText) messageText.textContent = message;
            if (messageBox) messageBox.classList.remove('hidden');
        }

        /**
         * Updates the text of the "Remove" button with the current number of tourists.
         */
        function updateClearButtonText() {
            if (clearButton) {
                const buttonLabel = touristCount === 1 ? 'touri' : 'touris';
                clearButton.textContent = `remove ${touristCount.toLocaleString('de-DE')} ${buttonLabel}`;
            }
        }

        /**
         * Updates the display of the total generated tourists (for this session only).
         */
        function updateAllTimeStatsDisplay() {
            if (allTimeStatsDisplay) {
                const label = allTimeTouristCount === 1 ? 'touri generated' : 'touris generated';
                allTimeStatsDisplay.textContent = `${allTimeTouristCount.toLocaleString('de-DE')} ${label}`;
            }
        }
        
        /**
         * Starts the process of clearing the canvas and syncing with JSONBin.
         * The UI is updated immediately, the synchronization runs in the background.
         */
        async function clearCanvasAndSync() {
            const countToSync = touristCount;
            if (countToSync <= 0) return; // Nothing to do

            // --- Immediate UI Updates ---
            // 1. Remove tourists from the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 2. Reset local counter and button text
            touristCount = 0;
            updateClearButtonText(); // Sets the button to "remove 0 touris"

            // 3. Set global statistics to "Loading"
            const previousGlobalText = worldwideStatsDisplay.textContent;
            worldwideStatsDisplay.textContent = 'loading global stats...';

            // --- Asynchronous Background Update ---
            try {
                const currentGlobalCount = await getCounterValue();
                const newGlobalCount = currentGlobalCount + countToSync;
                const success = await updateCounterValue(newGlobalCount);

                if (success) {
                    // Update global statistics on success
                    worldwideStatsDisplay.textContent = `${newGlobalCount.toLocaleString('de-DE')} touris removed globally`;
                } else {
                    // Revert to previous text on failure
                    worldwideStatsDisplay.textContent = previousGlobalText;
                }
            } catch (error) {
                console.error("Error in synchronization process:", error);
                worldwideStatsDisplay.textContent = previousGlobalText; // Also revert on unexpected errors
                showMessage("Global synchronization failed.");
            }
        }


        // Event Listener for the Clear Button
        if (clearButton) {
            clearButton.addEventListener('click', clearCanvasAndSync);
        }

        // Colors for the mannequins
        const skinTones = ['#FAD2A5', '#E0B49A', '#C89F82', '#A9816B', '#8B6A56', '#6F5444'];
        const hairColors = ['#4A2C2A', '#6D4C41', '#B7A68E', '#D1C29B', '#F5E6CC', '#2C2C2C', '#A52A2A', '#FFDB58', '#E6E6FA'];
        const topColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#F7DC6F', '#BB8FCE', '#82E0AA', '#FFA07A', '#20B2AA', '#DDA0DD'];
        const pantColors = ['#5D4037', '#795548', '#3E2723', '#1E88E5', '#424242', '#607D8B', '#2c3e50', '#95a5a6'];

        /**
         * Draws a mannequin on the canvas at the specified position.
         * @param {number} x - The X-coordinate on the screen.
         * @param {number} y - The Y-coordinate on the screen.
         */
        function drawMannequin(x, y) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            const baseScale = 0.4 + Math.random() * 0.35; 
            const personLimbColor = skinTones[Math.floor(Math.random() * skinTones.length)];
            const personHeadColor = hairColors[Math.floor(Math.random() * hairColors.length)];
            const personTopColor = topColors[Math.floor(Math.random() * topColors.length)];
            const personPantColor = pantColors[Math.floor(Math.random() * pantColors.length)];

            ctx.save();
            ctx.translate(canvasX, canvasY);
            ctx.scale(baseScale, baseScale);

            const headRadius = 15;
            const headY = -35;
            const bodyWidth = 22;
            const bodyHeight = 38;
            const bodyY = headY + headRadius - 5;
            const limbThickness = 7;
            
            const pantsStartY = bodyY + bodyHeight;
            const pantsWidth = bodyWidth;

            const clothingRoll = Math.random();
            let clothingType; 
            let currentPantsHeight;
            const shortPantsHeight = 15;
            const longPantsHeight = 30;
            const longGarmentHeight = 40; 

            if (clothingRoll < 1/3) { 
                clothingType = 'short';
                currentPantsHeight = shortPantsHeight;
            } else if (clothingRoll < (1/3 + 1/2)) { 
                clothingType = 'longPants';
                currentPantsHeight = longPantsHeight;
            } else { 
                clothingType = 'longGarment';
                currentPantsHeight = longGarmentHeight;
            }

            ctx.strokeStyle = personLimbColor; 
            ctx.lineWidth = limbThickness;
            ctx.lineCap = 'round'; 

            if (clothingType === 'short') {
                const legOriginY = pantsStartY; 
                const legLineLengthBelowPants = 25; 
                const totalLegLengthFromOrigin = currentPantsHeight + legLineLengthBelowPants;
                const legBaseXOffset = bodyWidth / 4; 
                const legSpreadAtBottom = 8; 
                const footXLeft = -legBaseXOffset - legSpreadAtBottom;
                const footXRight = legBaseXOffset + legSpreadAtBottom;
                const legLineEndY = legOriginY + totalLegLengthFromOrigin;

                ctx.beginPath();
                ctx.moveTo(-legBaseXOffset, legOriginY); 
                ctx.lineTo(footXLeft, legLineEndY);     
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(legBaseXOffset, legOriginY);  
                ctx.lineTo(footXRight, legLineEndY);     
                ctx.stroke();
            }

            ctx.fillStyle = personPantColor;
            ctx.fillRect(-pantsWidth / 2, pantsStartY, pantsWidth, currentPantsHeight);

            if (clothingType === 'longPants') {
                const footStubLength = 5; 
                const footStubY = pantsStartY + currentPantsHeight; 
                const footStubXOffset = pantsWidth / 4.2; 

                ctx.strokeStyle = personLimbColor;
                ctx.lineCap = 'round'; 

                ctx.beginPath();
                ctx.moveTo(-footStubXOffset, footStubY);
                ctx.lineTo(-footStubXOffset, footStubY + footStubLength); 
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(footStubXOffset, footStubY);
                ctx.lineTo(footStubXOffset, footStubY + footStubLength); 
                ctx.stroke();
            } else if (clothingType === 'longGarment') {
                const footPeekLength = 4; 
                const footPeekY = pantsStartY + currentPantsHeight; 
                const footPeekXOffset = pantsWidth / 4.5; 

                ctx.strokeStyle = personLimbColor;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(-footPeekXOffset, footPeekY);
                ctx.lineTo(-footPeekXOffset, footPeekY + footPeekLength);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(footPeekXOffset, footPeekY);
                ctx.lineTo(footPeekXOffset, footPeekY + footPeekLength);
                ctx.stroke();
            }
            
            ctx.fillStyle = personTopColor;
            ctx.fillRect(-bodyWidth / 2, bodyY, bodyWidth, bodyHeight);

            ctx.strokeStyle = personLimbColor; 
            const armShoulderOffsetY = bodyY + bodyHeight * 0.20;
            const maxArmHorizontalOffset = 20;
            const armVerticalComponentAtMaxHorizontal = 15;
            const armLengthWhenStraightDown = 28;
            const angleRandomFactor = Math.random();
            const currentArmXEndOffset = angleRandomFactor * maxArmHorizontalOffset;
            const currentArmYEndOffset = (1 - angleRandomFactor) * armLengthWhenStraightDown + angleRandomFactor * armVerticalComponentAtMaxHorizontal;

            ctx.beginPath();
            ctx.moveTo(-bodyWidth / 2, armShoulderOffsetY);
            ctx.lineTo(-bodyWidth / 2 - currentArmXEndOffset, armShoulderOffsetY + currentArmYEndOffset);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bodyWidth / 2, armShoulderOffsetY);
            ctx.lineTo(bodyWidth / 2 + currentArmXEndOffset, armShoulderOffsetY + currentArmYEndOffset);
            ctx.stroke();

            ctx.fillStyle = personHeadColor;
            ctx.beginPath();
            ctx.arc(0, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            ctx.restore();

            // Update local counters
            touristCount++;
            allTimeTouristCount++; 
            updateClearButtonText();
            updateAllTimeStatsDisplay(); 
        }
        
        /**
         * The main game loop function that continuously draws mannequins when isDrawing is true.
         */
        function gameLoop() {
            if (!isDrawing) { 
                gameLoopTimeoutId = null; 
                return; 
            }
            drawMannequin(lastKnownX, lastKnownY); 
            gameLoopTimeoutId = setTimeout(gameLoop, GAME_LOOP_INTERVAL); 
        }

        /**
         * Updates the last known mouse or touch position.
         * @param {Event} event - The mouse or touch event.
         */
        function updateLastKnownPosition(event) {
            if (event.touches && event.touches.length > 0) {
                lastKnownX = event.touches[0].clientX;
                lastKnownY = event.touches[0].clientY;
            } else {
                lastKnownX = event.clientX;
                lastKnownY = event.clientY;
            }
        }

        /**
         * Starts the drawing interaction on mouse down or touch start.
         * @param {Event} event - The mouse or touch event.
         */
        function startDrawingInteraction(event) {
            if (event.target === screenshotButton || event.target.closest('#screenshotButton')) {
                return;
            }

            if (event.target !== canvas) {
                return;
            }
            isDrawing = true;
            updateLastKnownPosition(event);
            drawMannequin(lastKnownX, lastKnownY);

            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = setTimeout(() => {
                if (isDrawing) {
                    gameLoop();
                }
            }, HOLD_TO_START_LOOP_DELAY);

            window.addEventListener('mousemove', handleDrawingMove);
            window.addEventListener('touchmove', handleDrawingMove, { passive: false });
            window.addEventListener('mouseup', stopDrawingInteraction);
            window.addEventListener('touchend', stopDrawingInteraction);
            window.addEventListener('touchcancel', stopDrawingInteraction);
            window.addEventListener('mouseleave', stopDrawingInteraction); 
        }

        /**
         * Handles mouse move or touch move events for drawing.
         * @param {Event} event - The mouse or touch event.
         */
        function handleDrawingMove(event) {
            if (!isDrawing) return;
            
            if (event.type === 'touchmove') {
                event.preventDefault(); 
            }
            updateLastKnownPosition(event);
            
            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = null;

            if (isDrawing && gameLoopTimeoutId === null) {
                gameLoop();
            }
        }

        /**
         * Stops the drawing interaction on mouse up or touch end.
         */
        function stopDrawingInteraction() {
            if (!isDrawing) return; 
            isDrawing = false;
            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = null;
            
            window.removeEventListener('mousemove', handleDrawingMove);
            window.removeEventListener('touchmove', handleDrawingMove);
            window.removeEventListener('mouseup', stopDrawingInteraction);
            window.removeEventListener('touchend', stopDrawingInteraction);
            window.removeEventListener('touchcancel', stopDrawingInteraction);
            window.removeEventListener('mouseleave', stopDrawingInteraction);
        }

        /**
         * Adjusts the canvas size to the window size.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            touristCount = 0; 
            allTimeTouristCount = 0; // Reset session counter
            updateClearButtonText();
            updateAllTimeStatsDisplay(); 
        }

        /**
         * Creates a screenshot and offers it for sharing (mobile) or download (desktop).
         */
        async function takeScreenshot() {
            const wasMessageBoxHidden = messageBox.classList.contains('hidden');
            if (!wasMessageBoxHidden) messageBox.classList.add('hidden');
            
            clearButtonWrapper.style.display = 'none';
            screenshotButtonContainer.style.display = 'none'; 
            
            allTimeStatsDisplay.style.backgroundColor = 'transparent';
            allTimeStatsDisplay.style.border = 'none';
            allTimeStatsDisplay.style.color = 'white';
            worldwideStatsDisplay.style.backgroundColor = 'transparent';
            worldwideStatsDisplay.style.border = 'none';
            worldwideStatsDisplay.style.color = 'white';

            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const canvas = await html2canvas(document.body, {
                    useCORS: true,
                    allowTaint: true,
                });

                const image = canvas.toDataURL('image/png');
                const blob = await (await fetch(image)).blob();
                const file = new File([blob], 'overtourissimus_screenshot.png', { type: 'image/png' });

                if (navigator.share && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'Overtourissimus',
                        text: 'My overtourissimus creation.',
                    });
                } else {
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = 'overtourissimus_screenshot.png';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Error creating or sharing screenshot:", error);
                    showMessage("Could not create screenshot.");
                }
            } finally {
                if (!wasMessageBoxHidden) messageBox.classList.remove('hidden');
                
                clearButtonWrapper.style.display = 'block'; 
                screenshotButtonContainer.style.display = 'flex'; 
                
                allTimeStatsDisplay.style.backgroundColor = '';
                allTimeStatsDisplay.style.border = '';
                allTimeStatsDisplay.style.color = '';
                worldwideStatsDisplay.style.backgroundColor = '';
                worldwideStatsDisplay.style.border = '';
                worldwideStatsDisplay.style.color = '';
            }
        }


        // Event listeners for mouse and touch interactions
        canvas.addEventListener('touchstart', startDrawingInteraction, { passive: false });
        canvas.addEventListener('mousedown', startDrawingInteraction);
        
        // Event listener for the Screenshot button
        if (screenshotButton) {
            screenshotButton.addEventListener('click', takeScreenshot);
        }

        // Initialization on page load and resize
        window.addEventListener('load', async () => {
            resizeCanvas(); 
            // --- Load and display the current global value ---
            const globalCount = await getCounterValue();
            worldwideStatsDisplay.textContent = `${globalCount.toLocaleString('de-DE')} touris removed globally`;
        });
        window.addEventListener('resize', resizeCanvas);

        // Error handling for the canvas context
        if (!ctx) {
            console.error("Error: 2D context could not be retrieved from canvas.");
            if (messageBox && messageText) {
                showMessage("Error: Canvas is not supported.");
            }
        }
    </script>
</body>
</html>
