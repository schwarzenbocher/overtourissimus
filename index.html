<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>overtourissimus</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- HTML2Canvas Bibliothek für Screenshots -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body {
            font-family: "Inter", sans-serif;
            overflow: hidden; /* Verhindert Scrollen der gesamten Seite */
            margin: 0; /* Stellt sicher, dass kein Standard-Margin vorhanden ist */
        }
        canvas {
            touch-action: none; /* Verhindert Standard-Touch-Aktionen wie Scrollen/Zoomen auf dem Canvas-Element selbst */
            display: block; /* Um mögliche untere Abstände zu entfernen */
        }
        .font-outfit {
            font-family: 'Outfit', sans-serif;
        }
        /* Zusätzliche Stilregel für die Statistik-Anzeigen, um die vertikale Ausrichtung zu erzwingen */
        #allTimeStatsDisplay, #worldwideStatsDisplay {
            height: 20px; /* Feste Höhe setzen */
            line-height: 20px; /* Zeilenhöhe gleich der Höhe setzen für vertikale Zentrierung */
        }
    </style>
</head>
<body class="bg-black text-white flex flex-col items-center justify-center h-screen w-screen">
    <!-- Hauptcontainer füllt nun den gesamten Bildschirm ohne max-width/height Einschränkungen -->
    <div class="relative w-full h-full bg-black shadow-lg overflow-hidden">
        <!-- "overtourissimus" Schriftzug - Vertikal am Icon ausgerichtet -->
        <div class="absolute top-0 left-0 right-0 px-4 h-[52px] z-5 flex items-center justify-center"> 
            <h1 class="text-center font-bold text-xl font-outfit tracking-widest leading-none">overtourissimus</h1>
        </div>

        <!-- Neuer Container für den Screenshot-Button - mit hohem Z-Index, damit er immer im Vordergrund ist -->
        <div id="screenshotButtonContainer" class="absolute top-0 right-0 py-2 px-4 z-40 flex items-center justify-end">
            <button id="screenshotButton" class="bg-gray-800 hover:bg-gray-900 text-white p-1.5 rounded-md shadow-md transition-colors duration-200 flex items-center justify-center">
                <!-- Minimalistisches Kamera SVG Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-camera">
                    <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3Z"/>
                    <circle cx="12" cy="13" r="3"/>
                </svg>
            </button>
        </div>

        <!-- Canvas nun auch absolut positioniert und mit z-index:10, um über dem Text zu liegen -->
        <canvas id="overtourismCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>

        <!-- Message Box - bleibt auf der höchsten Ebene -->
        <div id="messageBox" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-800 text-white p-6 rounded-lg shadow-xl hidden z-50 text-center">
            <p id="messageText" class="mb-4"></p>
            <button onclick="document.getElementById('messageBox').classList.add('hidden')" class="mt-2 px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-sm font-medium">OK</button>
        </div>
    </div>

    <!-- Container für "Remove Touris" Button -->
    <div id="clearButtonWrapper" class="absolute bottom-[72px] left-1/2 -translate-x-1/2 z-30">
        <button id="clearButton" class="font-outfit px-4 py-2 bg-blue-800 hover:bg-blue-900 text-white text-sm rounded-md shadow-md w-96 text-center">
            remove 0 touris
        </button>
    </div>

    <!-- Container für "Touris Removed" Display -->
    <div id="allTimeStatsDisplay" class="absolute bottom-[44px] left-1/2 -translate-x-1/2 font-outfit px-4 py-1 bg-black text-gray-400 text-xs rounded-md w-96 text-center border border-gray-700 flex items-center justify-center z-30">
        0 touris removed
    </div>
    
    <!-- Container für "Worldwide Removed Touris" Display -->
    <div id="worldwideStatsDisplay" class="absolute bottom-4 left-1/2 -translate-x-1/2 font-outfit px-4 py-1 bg-black text-gray-400 text-xs rounded-md w-96 text-center border border-gray-700 flex items-center justify-center z-30">
        loading worldwide stats...
    </div>


    <script>
        const canvas = document.getElementById('overtourismCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const clearButton = document.getElementById('clearButton');
        const allTimeStatsDisplay = document.getElementById('allTimeStatsDisplay');
        const worldwideStatsDisplay = document.getElementById('worldwideStatsDisplay');
        const screenshotButton = document.getElementById('screenshotButton'); 
        const screenshotButtonContainer = document.getElementById('screenshotButtonContainer'); 
        const clearButtonWrapper = document.getElementById('clearButtonWrapper'); 

        // --- Abacus Counter API Konfiguration ---
        const namespace = "overtourissimus";
        const key = "tourists";
        const counterUrlGet = `https://abacus.jasoncameron.dev/get/${namespace}/${key}`;
        const counterUrlHit = `https://abacus.jasoncameron.dev/hit/${namespace}/${key}`;
        // --- Ende der API Konfiguration ---

        let isDrawing = false;
        let touristCount = 0; 
        let allTimeTouristCount = 0; 
        let lastKnownX = 0;
        let lastKnownY = 0;
        let gameLoopTimeoutId = null; 
        
        const GAME_LOOP_INTERVAL = 18; // Intervall für kontinuierliches Zeichnen
        const HOLD_TO_START_LOOP_DELAY = 150; // Verzögerung in ms, bevor Halten als kontinuierliches Zeichnen gilt

        /**
         * Sendet den lokalen Zählerstand an die globale API im Hintergrund.
         * @param {number} count - Die Anzahl der hinzuzufügenden Touristen.
         */
        async function sendLocalCountToGlobal(count) {
            if (count <= 0) return;

            const originalText = worldwideStatsDisplay.textContent;
            worldwideStatsDisplay.textContent = 'updating globally generated touris...';
            
            let lastData;
            for (let i = 0; i < count; i++) {
                try {
                    const response = await fetch(counterUrlHit);
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    lastData = await response.json();
                } catch (err) {
                    console.error("Counter API increment failed during batch update:", err);
                    worldwideStatsDisplay.textContent = originalText; // Bei Fehler zurücksetzen
                    return; // Schleife abbrechen
                }
            }

            if (lastData && typeof lastData.value !== 'undefined') {
                worldwideStatsDisplay.textContent = `${lastData.value.toLocaleString('de-DE')} worldwide removed touris`;
            } else {
                worldwideStatsDisplay.textContent = originalText; // Fallback
            }
        }

        /**
         * Zeigt eine Nachricht in der benutzerdefinierten Nachrichtenbox an.
         * @param {string} message - Die anzuzeigende Nachricht.
         */
        function showMessage(message) {
            if (messageText) {
                messageText.textContent = message;
            }
            if (messageBox) {
                messageBox.classList.remove('hidden');
            }
        }

        /**
         * Aktualisiert den Text des "Remove"-Buttons mit der aktuellen Anzahl der Touristen.
         * Beachtet den Singular für "1 touri".
         */
        function updateClearButtonText() {
            if (clearButton) {
                const buttonLabel = touristCount === 1 ? 'touri' : 'touris';
                clearButton.textContent = `remove ${touristCount.toLocaleString('de-DE')} ${buttonLabel}`;
            }
        }

        /**
         * Aktualisiert die Anzeige der insgesamt entfernten Touristen (nur für diese Sitzung).
         */
        function updateAllTimeStatsDisplay() {
            if (allTimeStatsDisplay) {
                allTimeStatsDisplay.textContent = `${allTimeTouristCount.toLocaleString('de-DE')} touris removed`;
            }
        }
        
        /**
         * Löscht den Canvas sofort und startet die Synchronisierung im Hintergrund.
         */
        function clearCanvasAndSync() {
            const countToSync = touristCount;
            if (countToSync <= 0) return; // Nichts zu tun

            // Sofortige Aktionen für eine reaktionsschnelle UI
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            touristCount = 0; 
            updateClearButtonText(); // Setzt den Button-Text sofort auf "remove 0 touris"

            // Hintergrundaktion: Sendet die Daten an die API, ohne darauf zu warten.
            sendLocalCountToGlobal(countToSync);
        }

        // Event Listener für den Clear Button
        if (clearButton) {
            clearButton.addEventListener('click', clearCanvasAndSync);
        }

        // Farben für die Mannequins
        const skinTones = ['#FAD2A5', '#E0B49A', '#C89F82', '#A9816B', '#8B6A56', '#6F5444'];
        const hairColors = ['#4A2C2A', '#6D4C41', '#B7A68E', '#D1C29B', '#F5E6CC', '#2C2C2C', '#A52A2A', '#FFDB58', '#E6E6FA'];
        const topColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#F7DC6F', '#BB8FCE', '#82E0AA', '#FFA07A', '#20B2AA', '#DDA0DD'];
        const pantColors = ['#5D4037', '#795548', '#3E2723', '#1E88E5', '#424242', '#607D8B', '#2c3e50', '#95a5a6'];

        /**
         * Zeichnet ein Mannequin auf dem Canvas an der angegebenen Position.
         * @param {number} x - Die X-Koordinate auf dem Bildschirm.
         * @param {number} y - Die Y-Koordinate auf dem Bildschirm.
         */
        function drawMannequin(x, y) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            const baseScale = 0.4 + Math.random() * 0.35; 
            const personLimbColor = skinTones[Math.floor(Math.random() * skinTones.length)];
            const personHeadColor = hairColors[Math.floor(Math.random() * hairColors.length)];
            const personTopColor = topColors[Math.floor(Math.random() * topColors.length)];
            const personPantColor = pantColors[Math.floor(Math.random() * pantColors.length)];

            ctx.save();
            ctx.translate(canvasX, canvasY);
            ctx.scale(baseScale, baseScale);

            const headRadius = 15;
            const headY = -35;
            const bodyWidth = 22;
            const bodyHeight = 38;
            const bodyY = headY + headRadius - 5;
            const limbThickness = 7;
            
            const pantsStartY = bodyY + bodyHeight;
            const pantsWidth = bodyWidth;

            const clothingRoll = Math.random();
            let clothingType; 
            let currentPantsHeight;
            const shortPantsHeight = 15;
            const longPantsHeight = 30;
            const longGarmentHeight = 40; 

            if (clothingRoll < 1/3) { 
                clothingType = 'short';
                currentPantsHeight = shortPantsHeight;
            } else if (clothingRoll < (1/3 + 1/2)) { 
                clothingType = 'longPants';
                currentPantsHeight = longPantsHeight;
            } else { 
                clothingType = 'longGarment';
                currentPantsHeight = longGarmentHeight;
            }

            ctx.strokeStyle = personLimbColor; 
            ctx.lineWidth = limbThickness;
            ctx.lineCap = 'round'; 

            if (clothingType === 'short') {
                const legOriginY = pantsStartY; 
                const legLineLengthBelowPants = 25; 
                const totalLegLengthFromOrigin = currentPantsHeight + legLineLengthBelowPants;
                const legBaseXOffset = bodyWidth / 4; 
                const legSpreadAtBottom = 8; 
                const footXLeft = -legBaseXOffset - legSpreadAtBottom;
                const footXRight = legBaseXOffset + legSpreadAtBottom;
                const legLineEndY = legOriginY + totalLegLengthFromOrigin;

                ctx.beginPath();
                ctx.moveTo(-legBaseXOffset, legOriginY); 
                ctx.lineTo(footXLeft, legLineEndY);      
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(legBaseXOffset, legOriginY);  
                ctx.lineTo(footXRight, legLineEndY);     
                ctx.stroke();
            }

            ctx.fillStyle = personPantColor;
            ctx.fillRect(-pantsWidth / 2, pantsStartY, pantsWidth, currentPantsHeight);

            if (clothingType === 'longPants') {
                const footStubLength = 5; 
                const footStubY = pantsStartY + currentPantsHeight; 
                const footStubXOffset = pantsWidth / 4.2; 

                ctx.strokeStyle = personLimbColor;
                ctx.lineCap = 'round'; 

                ctx.beginPath();
                ctx.moveTo(-footStubXOffset, footStubY);
                ctx.lineTo(-footStubXOffset, footStubY + footStubLength); 
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(footStubXOffset, footStubY);
                ctx.lineTo(footStubXOffset, footStubY + footStubLength); 
                ctx.stroke();
            } else if (clothingType === 'longGarment') {
                const footPeekLength = 4; 
                const footPeekY = pantsStartY + currentPantsHeight; 
                const footPeekXOffset = pantsWidth / 4.5; 

                ctx.strokeStyle = personLimbColor;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(-footPeekXOffset, footPeekY);
                ctx.lineTo(-footPeekXOffset, footPeekY + footPeekLength);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(footPeekXOffset, footPeekY);
                ctx.lineTo(footPeekXOffset, footPeekY + footPeekLength);
                ctx.stroke();
            }
            
            ctx.fillStyle = personTopColor;
            ctx.fillRect(-bodyWidth / 2, bodyY, bodyWidth, bodyHeight);

            ctx.strokeStyle = personLimbColor; 
            const armShoulderOffsetY = bodyY + bodyHeight * 0.20;
            const maxArmHorizontalOffset = 20;
            const armVerticalComponentAtMaxHorizontal = 15;
            const armLengthWhenStraightDown = 28;
            const angleRandomFactor = Math.random();
            const currentArmXEndOffset = angleRandomFactor * maxArmHorizontalOffset;
            const currentArmYEndOffset = (1 - angleRandomFactor) * armLengthWhenStraightDown + angleRandomFactor * armVerticalComponentAtMaxHorizontal;

            ctx.beginPath();
            ctx.moveTo(-bodyWidth / 2, armShoulderOffsetY);
            ctx.lineTo(-bodyWidth / 2 - currentArmXEndOffset, armShoulderOffsetY + currentArmYEndOffset);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bodyWidth / 2, armShoulderOffsetY);
            ctx.lineTo(bodyWidth / 2 + currentArmXEndOffset, armShoulderOffsetY + currentArmYEndOffset);
            ctx.stroke();

            ctx.fillStyle = personHeadColor;
            ctx.beginPath();
            ctx.arc(0, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            ctx.restore();

            // Lokale Zähler aktualisieren
            touristCount++;
            allTimeTouristCount++; 
            updateClearButtonText();
            updateAllTimeStatsDisplay(); 
        }
        
        /**
         * Die Haupt-Game-Loop-Funktion, die kontinuierlich Mannequins zeichnet, wenn isDrawing true ist.
         */
        function gameLoop() {
            if (!isDrawing) { 
                gameLoopTimeoutId = null; 
                return; 
            }
            drawMannequin(lastKnownX, lastKnownY); 
            gameLoopTimeoutId = setTimeout(gameLoop, GAME_LOOP_INTERVAL); 
        }

        /**
         * Aktualisiert die zuletzt bekannte Maus- oder Touch-Position.
         * @param {Event} event - Das Maus- oder Touch-Event.
         */
        function updateLastKnownPosition(event) {
            if (event.touches && event.touches.length > 0) {
                lastKnownX = event.touches[0].clientX;
                lastKnownY = event.touches[0].clientY;
            } else {
                lastKnownX = event.clientX;
                lastKnownY = event.clientY;
            }
        }

        /**
         * Startet die Zeicheninteraktion bei Maus-Down oder Touch-Start.
         * @param {Event} event - Das Maus- oder Touch-Event.
         */
        function startDrawingInteraction(event) {
            if (event.target === screenshotButton || event.target.closest('#screenshotButton')) {
                return;
            }

            if (event.target !== canvas) {
                return;
            }
            isDrawing = true;
            updateLastKnownPosition(event);
            drawMannequin(lastKnownX, lastKnownY);

            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = setTimeout(() => {
                if (isDrawing) {
                    gameLoop();
                }
            }, HOLD_TO_START_LOOP_DELAY);

            window.addEventListener('mousemove', handleDrawingMove);
            window.addEventListener('touchmove', handleDrawingMove, { passive: false });
            window.addEventListener('mouseup', stopDrawingInteraction);
            window.addEventListener('touchend', stopDrawingInteraction);
            window.addEventListener('touchcancel', stopDrawingInteraction);
            window.addEventListener('mouseleave', stopDrawingInteraction); 
        }

        /**
         * Behandelt Maus-Move- oder Touch-Move-Events zum Zeichnen.
         * @param {Event} event - Das Maus- oder Touch-Event.
         */
        function handleDrawingMove(event) {
            if (!isDrawing) return;
            
            if (event.type === 'touchmove') {
                event.preventDefault(); 
            }
            updateLastKnownPosition(event);
            
            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = null;

            if (isDrawing && gameLoopTimeoutId === null) {
                gameLoop();
            }
        }

        /**
         * Stoppt die Zeicheninteraktion bei Maus-Up oder Touch-End.
         */
        function stopDrawingInteraction() {
            if (!isDrawing) return; 
            isDrawing = false;
            clearTimeout(gameLoopTimeoutId);
            gameLoopTimeoutId = null;
            
            window.removeEventListener('mousemove', handleDrawingMove);
            window.removeEventListener('touchmove', handleDrawingMove);
            window.removeEventListener('mouseup', stopDrawingInteraction);
            window.removeEventListener('touchend', stopDrawingInteraction);
            window.removeEventListener('touchcancel', stopDrawingInteraction);
            window.removeEventListener('mouseleave', stopDrawingInteraction);
        }

        /**
         * Passt die Canvas-Größe an die Fenstergröße an.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            touristCount = 0; 
            updateClearButtonText();
            updateAllTimeStatsDisplay(); 
        }

        /**
         * Erstellt einen Screenshot und bietet ihn zum Teilen (mobil) oder Download (desktop) an.
         */
        async function takeScreenshot() {
            const wasMessageBoxHidden = messageBox.classList.contains('hidden');
            if (!wasMessageBoxHidden) messageBox.classList.add('hidden');
            
            clearButtonWrapper.style.display = 'none';
            screenshotButtonContainer.style.display = 'none'; 
            
            allTimeStatsDisplay.style.backgroundColor = 'transparent';
            allTimeStatsDisplay.style.border = 'none';
            allTimeStatsDisplay.style.color = 'white';
            worldwideStatsDisplay.style.backgroundColor = 'transparent';
            worldwideStatsDisplay.style.border = 'none';
            worldwideStatsDisplay.style.color = 'white';

            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const canvas = await html2canvas(document.body, {
                    useCORS: true,
                    allowTaint: true,
                });

                const image = canvas.toDataURL('image/png');
                const blob = await (await fetch(image)).blob();
                const file = new File([blob], 'overtourissimus_screenshot.png', { type: 'image/png' });

                if (navigator.share && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'Overtourissimus',
                        text: 'My overtourissimus creation.',
                    });
                } else {
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = 'overtourissimus_screenshot.png';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Fehler beim Erstellen oder Teilen des Screenshots:", error);
                    showMessage("Screenshot konnte nicht erstellt werden.");
                }
            } finally {
                if (!wasMessageBoxHidden) messageBox.classList.remove('hidden');
                
                clearButtonWrapper.style.display = 'block'; 
                screenshotButtonContainer.style.display = 'flex'; 
                
                allTimeStatsDisplay.style.backgroundColor = '';
                allTimeStatsDisplay.style.border = '';
                allTimeStatsDisplay.style.color = '';
                worldwideStatsDisplay.style.backgroundColor = '';
                worldwideStatsDisplay.style.border = '';
                worldwideStatsDisplay.style.color = '';
            }
        }


        // Event listeners for mouse and touch interactions
        canvas.addEventListener('touchstart', startDrawingInteraction, { passive: false });
        canvas.addEventListener('mousedown', startDrawingInteraction);
        
        // Event listener for the Screenshot button
        if (screenshotButton) {
            screenshotButton.addEventListener('click', takeScreenshot);
        }

        // Initialization on page load and resize
        window.addEventListener('load', () => {
            resizeCanvas(); 
            // --- Aktuellen globalen Wert laden und anzeigen ---
            fetch(counterUrlGet)
                .then(response => response.json())
                .then(data => {
                    const globalCount = data.value ?? 0; // Falls Key nicht existiert, ist data.value undefined
                    worldwideStatsDisplay.textContent = 
                        `${globalCount.toLocaleString('de-DE')} worldwide removed touris`;
                })
                .catch(err => {
                    console.error("Counter API GET failed:", err);
                    worldwideStatsDisplay.textContent = "Could not load worldwide stats";
                });
        });
        window.addEventListener('resize', resizeCanvas);

        // Error handling for the canvas context
        if (!ctx) {
            console.error("Error: 2D context could not be retrieved from canvas.");
            if (messageBox && messageText) {
                showMessage("Error: Canvas is not supported.");
            }
        }
    </script>
</body>
</html>
